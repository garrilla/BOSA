[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package['modules-runtime'].meteorInstall;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"modules\":{\"client.js\":function module(require,exports){\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                                                                  //\n// packages/modules/client.js                                                       //\n//                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////\n                                                                                    //\nrequire(\"./install-packages.js\");\nrequire(\"./stubs.js\");\nrequire(\"./process.js\");\nrequire(\"./reify.js\");\n\nexports.addStyles = require(\"./css\").addStyles;\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n},\"css.js\":function module(require,exports){\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                                                                  //\n// packages/modules/css.js                                                          //\n//                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////\n                                                                                    //\nvar doc = document;\nvar head = doc.getElementsByTagName(\"head\").item(0);\n\nexports.addStyles = function (css) {\n  var style = doc.createElement(\"style\");\n\n  style.setAttribute(\"type\", \"text/css\");\n\n  // https://msdn.microsoft.com/en-us/library/ms535871(v=vs.85).aspx\n  var internetExplorerSheetObject =\n    style.sheet || // Edge/IE11.\n    style.styleSheet; // Older IEs.\n\n  if (internetExplorerSheetObject) {\n    internetExplorerSheetObject.cssText = css;\n  } else {\n    style.appendChild(doc.createTextNode(css));\n  }\n\n  return head.appendChild(style);\n};\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n},\"install-packages.js\":function module(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                                                                  //\n// packages/modules/install-packages.js                                             //\n//                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////\n                                                                                    //\nfunction install(name, mainModule) {\n  var meteorDir = {};\n\n  // Given a package name <name>, install a stub module in the\n  // /node_modules/meteor directory called <name>.js, so that\n  // require.resolve(\"meteor/<name>\") will always return\n  // /node_modules/meteor/<name>.js instead of something like\n  // /node_modules/meteor/<name>/index.js, in the rare but possible event\n  // that the package contains a file called index.js (#6590).\n\n  if (typeof mainModule === \"string\") {\n    // Set up an alias from /node_modules/meteor/<package>.js to the main\n    // module, e.g. meteor/<package>/index.js.\n    meteorDir[name + \".js\"] = mainModule;\n  } else {\n    // back compat with old Meteor packages\n    meteorDir[name + \".js\"] = function (r, e, module) {\n      module.exports = Package[name];\n    };\n  }\n\n  meteorInstall({\n    node_modules: {\n      meteor: meteorDir\n    }\n  });\n}\n\n// This file will be modified during computeJsOutputFilesMap to include\n// install(<name>) calls for every Meteor package.\n\ninstall(\"meteor\");\ninstall(\"meteor-base\");\ninstall(\"mobile-experience\");\ninstall(\"modules-runtime\");\ninstall(\"modules-runtime-hot\");\ninstall(\"modules\", \"meteor/modules/client.js\");\ninstall(\"modern-browsers\");\ninstall(\"babel-compiler\");\ninstall(\"es5-shim\");\ninstall(\"promise\", \"meteor/promise/client.js\");\ninstall(\"ecmascript-runtime-client\", \"meteor/ecmascript-runtime-client/modern.js\");\ninstall(\"hot-module-replacement\");\ninstall(\"react-fast-refresh\");\ninstall(\"ecmascript\");\ninstall(\"ecmascript-runtime\");\ninstall(\"babel-runtime\");\ninstall(\"fetch\", \"meteor/fetch/modern.js\");\ninstall(\"dynamic-import\", \"meteor/dynamic-import/client.js\");\ninstall(\"base64\", \"meteor/base64/base64.js\");\ninstall(\"ejson\", \"meteor/ejson/ejson.js\");\ninstall(\"diff-sequence\", \"meteor/diff-sequence/diff.js\");\ninstall(\"geojson-utils\", \"meteor/geojson-utils/main.js\");\ninstall(\"id-map\", \"meteor/id-map/id-map.js\");\ninstall(\"random\", \"meteor/random/main_client.js\");\ninstall(\"mongo-id\", \"meteor/mongo-id/id.js\");\ninstall(\"ordered-dict\", \"meteor/ordered-dict/ordered_dict.js\");\ninstall(\"tracker\");\ninstall(\"minimongo\", \"meteor/minimongo/minimongo_client.js\");\ninstall(\"check\", \"meteor/check/match.js\");\ninstall(\"retry\", \"meteor/retry/retry.js\");\ninstall(\"callback-hook\", \"meteor/callback-hook/hook.js\");\ninstall(\"ddp-common\");\ninstall(\"reload\", \"meteor/reload/reload.js\");\ninstall(\"socket-stream-client\", \"meteor/socket-stream-client/browser.js\");\ninstall(\"ddp-client\", \"meteor/ddp-client/client/client.js\");\ninstall(\"ddp\");\ninstall(\"ddp-server\");\ninstall(\"allow-deny\");\ninstall(\"mongo-dev-server\");\ninstall(\"logging\", \"meteor/logging/logging.js\");\ninstall(\"insecure\");\ninstall(\"mongo\");\ninstall(\"reactive-var\");\ninstall(\"standard-minifier-js\");\ninstall(\"typescript\");\ninstall(\"shell-server\");\ninstall(\"static-html\");\ninstall(\"react-meteor-data\", \"meteor/react-meteor-data/index.js\");\ninstall(\"simple:rest\");\ninstall(\"juliancwirko:postcss\");\ninstall(\"webapp\", \"meteor/webapp/webapp_client.js\");\ninstall(\"hot-code-push\");\ninstall(\"launch-screen\");\ninstall(\"autoupdate\", \"meteor/autoupdate/autoupdate_client.js\");\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n},\"process.js\":function module(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                                                                  //\n// packages/modules/process.js                                                      //\n//                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////\n                                                                                    //\nif (! global.process) {\n  try {\n    // The application can run `npm install process` to provide its own\n    // process stub; otherwise this module will provide a partial stub.\n    global.process = require(\"process\");\n  } catch (missing) {\n    global.process = {};\n  }\n}\n\nvar proc = global.process;\n\nif (Meteor.isServer) {\n  // Make require(\"process\") work on the server in all versions of Node.\n  meteorInstall({\n    node_modules: {\n      \"process.js\": function (r, e, module) {\n        module.exports = proc;\n      }\n    }\n  });\n} else {\n  proc.platform = \"browser\";\n  proc.nextTick = proc.nextTick || Meteor._setImmediate;\n}\n\nif (typeof proc.env !== \"object\") {\n  proc.env = {};\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nfor (var key in meteorEnv) {\n  if (hasOwn.call(meteorEnv, key)) {\n    proc.env[key] = meteorEnv[key];\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n},\"reify.js\":function module(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                                                                  //\n// packages/modules/reify.js                                                        //\n//                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////\n                                                                                    //\nrequire(\"@meteorjs/reify/lib/runtime\").enable(\n  module.constructor.prototype\n);\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n},\"stubs.js\":function module(require){\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                                                                  //\n// packages/modules/stubs.js                                                        //\n//                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////\n                                                                                    //\nvar haveStubs = false;\ntry {\n  require.resolve(\"meteor-node-stubs\");\n  haveStubs = true;\n} catch (noStubs) {}\n\nif (haveStubs) {\n  // When meteor-node-stubs is installed in the application's root\n  // node_modules directory, requiring it here installs aliases for stubs\n  // for all Node built-in modules, such as fs, util, and http.\n  require(\"meteor-node-stubs\");\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n},\"node_modules\":{\"@meteorjs\":{\"reify\":{\"lib\":{\"runtime\":{\"index.js\":function module(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                                                                  //\n// node_modules/meteor/modules/node_modules/@meteorjs/reify/lib/runtime/index.js    //\n//                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////\n                                                                                    //\n\"use strict\";\n\n// This module should be compatible with PhantomJS v1, just like the other files\n// in reify/lib/runtime. Node 4+ features like const/let and arrow functions are\n// not acceptable here, and importing any npm packages should be contemplated\n// with extreme skepticism.\n\nvar utils = require(\"./utils.js\");\nvar Entry = require(\"./entry.js\");\n\n// The exports.enable method can be used to enable the Reify runtime for\n// specific module objects, or for Module.prototype (where implemented),\n// to make the runtime available throughout the entire module system.\nexports.enable = function (mod) {\n  if (mod.link !== moduleLink) {\n    mod.link = moduleLink;\n    mod[\"export\"] = moduleExport;\n    mod.exportDefault = moduleExportDefault;\n    mod.exportAs = moduleExportAs;\n    mod.runSetters = runSetters;\n\n    // Legacy shorthand for mod.exportAs(\"*\").\n    mod.makeNsSetter = moduleMakeNsSetter;\n\n    return true;\n  }\n\n  return false;\n};\n\n// Calling module.link(id, setters) resolves the given ID using\n// module.resolve(id), which should return a canonical absolute module\n// identifier string (like require.resolve); then creates an Entry object\n// for the child module and evaluates its code (if this is the first time\n// it has been imported) by calling module.require(id). Finally, the\n// provided setter functions will be called with values exported by the\n// module, possibly multiple times when/if those exported values change.\n// The module.link name is intended to evoke the \"liveness\" of the\n// exported bindings, since we are subscribing to all future exports of\n// the child module, not just taking a snapshot of its current exports.\nfunction moduleLink(id, setters, key) {\n  utils.setESModule(this.exports);\n  Entry.getOrCreate(this.id, this);\n\n  var absChildId = this.resolve(id);\n  var childEntry = Entry.getOrCreate(absChildId);\n\n  if (utils.isObject(setters)) {\n    childEntry.addSetters(this, setters, key);\n  }\n\n  var exports = this.require(absChildId);\n\n  if (childEntry.module === null) {\n    childEntry.module = {\n      id: absChildId,\n      exports: exports\n    };\n  }\n\n  childEntry.runSetters();\n}\n\n// Register getter functions for local variables in the scope of an export\n// statement. Pass true as the second argument to indicate that the getter\n// functions always return the same values.\nfunction moduleExport(getters, constant) {\n  utils.setESModule(this.exports);\n  var entry = Entry.getOrCreate(this.id, this);\n  entry.addGetters(getters, constant);\n  if (this.loaded) {\n    // If the module has already been evaluated, then we need to trigger\n    // another round of entry.runSetters calls, which begins by calling\n    // entry.runModuleGetters(module).\n    entry.runSetters();\n  }\n}\n\n// Register a getter function that always returns the given value.\nfunction moduleExportDefault(value) {\n  return this[\"export\"]({\n    \"default\": function () {\n      return value;\n    }\n  }, true);\n}\n\n// Returns a function suitable for passing as a setter callback to\n// module.link. If name is an identifier, calling the function will set\n// the export of that name to the given value. If the name is \"*\", all\n// properties of the value object will be exported by name, except for\n// \"default\" (use \"*+\" instead of \"*\" to include it). Why the \"default\"\n// property is skipped: https://github.com/tc39/ecma262/issues/948\nfunction moduleExportAs(name) {\n  var entry = this;\n  var includeDefault = name === \"*+\";\n  var setter = function (value) {\n    if (name === \"*\" || name === \"*+\") {\n      Object.keys(value).forEach(function (key) {\n        if (includeDefault || key !== \"default\") {\n          utils.copyKey(key, entry.exports, value);\n        }\n      });\n    } else {\n      entry.exports[name] = value;\n    }\n  };\n\n  if (name !== '*+' && name !== \"*\") {\n    setter.exportAs = name;\n  }\n\n  return setter;\n}\n\n// Platform-specific code should find a way to call this method whenever\n// the module system is about to return module.exports from require. This\n// might happen more than once per module, in case of dependency cycles,\n// so we want Module.prototype.runSetters to run each time.\nfunction runSetters(valueToPassThrough, names) {\n  Entry.getOrCreate(this.id, this).runSetters(names, true);\n\n  // Assignments to exported local variables get wrapped with calls to\n  // module.runSetters, so module.runSetters returns the\n  // valueToPassThrough parameter to allow the value of the original\n  // expression to pass through. For example,\n  //\n  //   export var a = 1;\n  //   console.log(a += 3);\n  //\n  // becomes\n  //\n  //   module.export(\"a\", () => a);\n  //   var a = 1;\n  //   console.log(module.runSetters(a += 3));\n  //\n  // This ensures module.runSetters runs immediately after the assignment,\n  // and does not interfere with the larger computation.\n  return valueToPassThrough;\n}\n\n// Legacy helper that returns a function that takes a namespace object and\n// copies the properties of the namespace to module.exports, excluding any\n// \"default\" property (unless includeDefault is true), which is useful for\n// implementing `export * from \"module\"`.\n//\n// Instead of using this helper like so:\n//\n//   module.link(id, { \"*\": module.makeNsSetter() });\n//\n// non-legacy code should simply use a string-valued setter:\n//\n//   module.link(id, { \"*\": \"*\" });\n//\n// or, to include the \"default\" property:\n//\n//   module.link(id, { \"*\": \"*+\" });\n//\n// This helper may be removed in a future version of Reify.\nfunction moduleMakeNsSetter(includeDefault) {\n  return this.exportAs(includeDefault ? \"*+\" : \"*\");\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n},\"utils.js\":function module(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                                                                  //\n// node_modules/meteor/modules/node_modules/@meteorjs/reify/lib/runtime/utils.js    //\n//                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////\n                                                                                    //\n\"use strict\";\n\n// This module should be compatible with PhantomJS v1, just like the other files\n// in reify/lib/runtime. Node 4+ features like const/let and arrow functions are\n// not acceptable here, and importing any npm packages should be contemplated\n// with extreme skepticism.\n\nvar useSetPrototypeOf = typeof Object.setPrototypeOf === \"function\";\nvar useSymbol = typeof Symbol === \"function\";\n\nvar esStrKey = \"__esModule\";\nvar esSymKey = useSymbol ? Symbol.for(esStrKey) : null;\nvar useToStringTag = useSymbol && typeof Symbol.toStringTag === \"symbol\";\nvar useGetOwnPropDesc =\n  typeof Object.getOwnPropertyDescriptor === \"function\";\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction copyKey(key, target, source) {\n  if (useGetOwnPropDesc) {\n    var desc = Object.getOwnPropertyDescriptor(source, key);\n    desc.configurable = true; // Allow redefinition.\n    Object.defineProperty(target, key, desc);\n  } else {\n    target[key] = source[key];\n  }\n}\n\nexports.copyKey = copyKey;\n\n// Returns obj[key] unless that property is defined by a getter function,\n// in which case the getter function is returned.\nexports.valueOrGetter = function (obj, key) {\n  if (useGetOwnPropDesc && hasOwn.call(obj, key)) {\n    var desc = Object.getOwnPropertyDescriptor(obj, key);\n    if (typeof desc.get === \"function\") {\n      return desc.get;\n    }\n  }\n\n  return obj[key];\n};\n\nfunction getESModule(exported) {\n  if (isObjectLike(exported)) {\n    if (useSymbol && hasOwn.call(exported, esSymKey)) {\n      return !! exported[esSymKey];\n    }\n\n    if (hasOwn.call(exported, esStrKey)) {\n      return !! exported[esStrKey];\n    }\n  }\n\n  return false;\n}\n\nexports.getESModule = getESModule;\n\nfunction setESModule(exported) {\n  if (isObjectLike(exported)) {\n    if (useSymbol) {\n      exported[esSymKey] = true;\n    }\n\n    if (! exported[esStrKey]) {\n      // Other module runtime systems may set exported.__esModule such\n      // that it can't be redefined, so we call Object.defineProperty only\n      // when exported.__esModule is not already true.\n      Object.defineProperty(exported, esStrKey, {\n        configurable: true,\n        enumerable: false,\n        value: true,\n        writable: false\n      });\n    }\n  }\n}\n\nexports.setESModule = setESModule;\n\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\n\nexports.isObject = isObject;\n\nfunction isObjectLike(value) {\n  var type = typeof value;\n  return type === \"function\" || (type === \"object\" && value !== null);\n}\n\nexports.isObjectLike = isObjectLike;\n\nexports.ensureObjectProperty = function (object, propertyName) {\n  return hasOwn.call(object, propertyName)\n    ? object[propertyName]\n    : object[propertyName] = Object.create(null);\n};\n\nfunction createNamespace() {\n  var namespace = Object.create(null);\n\n  if (useToStringTag) {\n    Object.defineProperty(namespace, Symbol.toStringTag, {\n      value: \"Module\",\n      configurable: false,\n      enumerable: false,\n      writable: false\n    });\n  }\n\n  setESModule(namespace);\n\n  return namespace;\n}\n\nexports.createNamespace = createNamespace;\n\nfunction setPrototypeOf(object, proto) {\n  if (useSetPrototypeOf) {\n    Object.setPrototypeOf(object, proto);\n  } else {\n    object.__proto__ = proto;\n  }\n  return object;\n}\n\nexports.setPrototypeOf = setPrototypeOf;\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n},\"entry.js\":function module(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                                                                  //\n// node_modules/meteor/modules/node_modules/@meteorjs/reify/lib/runtime/entry.js    //\n//                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////\n                                                                                    //\n\"use strict\";\n\n// This module should be compatible with PhantomJS v1, just like the other files\n// in reify/lib/runtime. Node 4+ features like const/let and arrow functions are\n// not acceptable here, and importing any npm packages should be contemplated\n// with extreme skepticism.\n\nvar utils = require(\"./utils.js\");\n\nvar GETTER_ERROR = {};\nvar NAN = {};\nvar UNDEFINED = {};\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar keySalt = 0;\n\nfunction Entry(id) {\n  // The canonical absolute module ID of the module this Entry manages.\n  this.id = id;\n\n  // The Module object this Entry manages, unknown until module.export or\n  // module.link is called for the first time.\n  this.module = null;\n\n  // The normalized namespace object that importers receive when they use\n  // `import * as namespace from \"...\"` syntax.\n  this.namespace = utils.createNamespace();\n\n  // Getters for local variables exported from the managed module.\n  this.getters = Object.create(null);\n\n  // Setters for assigning to local variables in parent modules.\n  this.setters = Object.create(null);\n\n  // Map of setters added since the last broadcast (in the same shape as\n  // entry.setters[name][key]), which should receive a broadcast the next time\n  // entry.runSetters() is called, regardless of whether entry.snapshots[name]\n  // has changed or not. Once called, setters are removed from this.newSetters,\n  // but remain in this.setters.\n  this.newSetters = Object.create(null);\n\n  // Map from local names to snapshots of the corresponding local values, used\n  // to determine when local values have changed and need to be re-broadcast.\n  this.snapshots = Object.create(null);\n}\n\nvar Ep = utils.setPrototypeOf(Entry.prototype, null);\nvar entryMap = Object.create(null);\n\nEntry.getOrCreate = function (id, mod) {\n  var entry = hasOwn.call(entryMap, id)\n    ? entryMap[id]\n    : entryMap[id] = new Entry(id);\n\n  if (utils.isObject(mod) &&\n      mod.id === entry.id) {\n    entry.module = mod;\n  }\n\n  return entry;\n};\n\nfunction safeKeys(obj) {\n  var keys = Object.keys(obj);\n  var esModuleIndex = keys.indexOf(\"__esModule\");\n  if (esModuleIndex >= 0) {\n    keys.splice(esModuleIndex, 1);\n  }\n  return keys;\n}\n\nEp.addGetters = function (getters, constant) {\n  var names = safeKeys(getters);\n  var nameCount = names.length;\n  constant = !! constant;\n\n  for (var i = 0; i < nameCount; ++i) {\n    var name = names[i];\n    var getter = getters[name];\n\n    if (typeof getter === \"function\" &&\n        // Should this throw if this.getters[name] exists?\n        ! (name in this.getters)) {\n      this.getters[name] = getter;\n      getter.constant = constant;\n      getter.runCount = 0;\n    }\n  }\n};\n\nEp.addSetters = function (parent, setters, key) {\n  var names = safeKeys(setters);\n  var nameCount = names.length;\n\n  if (! nameCount) {\n    return;\n  }\n\n  // If no key is provided, make a unique key. Otherwise, make sure the key is\n  // distinct from keys provided by other parent modules.\n  key = key === void 0\n    ? makeUniqueKey()\n    : parent.id + \":\" + key;\n\n  var entry = this;\n\n  for (var i = 0; i < nameCount; ++i) {\n    var name = names[i];\n    var setter = normalizeSetterValue(parent, setters[name]);\n\n    if (typeof setter === \"function\") {\n      setter.parent = parent;\n      // Store the setter as entry.setters[name][key], and also record it\n      // temporarily in entry.newSetters, so we can be sure to run it when we\n      // call entry.runSetters(names) below, even though entry.snapshots[name]\n      // likely will not have changed for this name.\n      utils.ensureObjectProperty(entry.setters, name)[key] = setter;\n      utils.ensureObjectProperty(entry.newSetters, name)[key] = setter;\n    }\n  }\n\n  entry.runSetters(names);\n};\n\nfunction normalizeSetterValue(module, setter) {\n  if (typeof setter === \"function\") {\n    return setter;\n  }\n\n  if (typeof setter === \"string\") {\n    // If the value of the setter property is a string, the setter will\n    // re-export the imported value using that string as the name of the\n    // exported value. If the string is \"*\", all properties of the value\n    // object will be re-exported as individual exports, except for the\n    // \"default\" property (use \"*+\" instead of \"*\" to include it).\n    return module.exportAs(setter);\n  }\n\n  if (Array.isArray(setter)) {\n    switch (setter.length) {\n    case 0: return null;\n    case 1: return normalizeSetterValue(module, setter[0]);\n    default:\n      var setterFns = setter.map(function (elem) {\n        return normalizeSetterValue(module, elem);\n      });\n\n      // Return a combined function that calls all of the nested setter\n      // functions with the same value.\n      return function (value) {\n        setterFns.forEach(function (fn) {\n          fn(value);\n        });\n      };\n    }\n  }\n\n  return null;\n}\n\nEp.runGetters = function (names) {\n  // Before running getters, copy anything added to the exports object\n  // over to the namespace. Values returned by getters take precedence\n  // over these values, but we don't want to miss anything.\n  syncExportsToNamespace(this, names);\n\n  if (names === void 0 ||\n      names.indexOf(\"*\") >= 0) {\n    names = Object.keys(this.getters);\n  }\n\n  var nameCount = names.length;\n\n  for (var i = 0; i < nameCount; ++i) {\n    var name = names[i];\n    var value = runGetter(this, name);\n\n    // If the getter is run without error, update both entry.namespace and\n    // module.exports with the current value so that CommonJS require\n    // calls remain consistent with module.watch.\n    if (value !== GETTER_ERROR) {\n      this.namespace[name] = value;\n      this.module.exports[name] = value;\n    }\n  }\n};\n\nfunction syncExportsToNamespace(entry, names) {\n  var setDefault = false;\n\n  if (entry.module === null) return;\n  var exports = entry.module.exports;\n\n  if (! utils.getESModule(exports)) {\n    // If the module entry is managing overrides module.exports, that\n    // value should be exposed as the .default property of the namespace,\n    // unless module.exports is marked as an ECMASCript module.\n    entry.namespace.default = exports;\n    setDefault = true;\n  }\n\n  if (! utils.isObjectLike(exports)) {\n    return;\n  }\n\n  if (names === void 0 ||\n      names.indexOf(\"*\") >= 0) {\n    names = Object.keys(exports);\n  }\n\n  names.forEach(function (key) {\n    // Don't set any properties for which a getter function exists in\n    // entry.getters, don't accidentally override entry.namespace.default,\n    // and only copy own properties from entry.module.exports.\n    if (! hasOwn.call(entry.getters, key) &&\n        ! (setDefault && key === \"default\") &&\n        hasOwn.call(exports, key)) {\n      utils.copyKey(key, entry.namespace, exports);\n    }\n  });\n}\n\n// Called whenever module.exports might have changed, to trigger any\n// setters associated with the newly exported values. The names parameter\n// is optional; without it, all getters and setters will run.\n// If the '*' setter needs to be run, but not the '*' getter (names includes\n// all exports/getters that changed), the runNsSetter option can be enabled.\nEp.runSetters = function (names, runNsSetter) {\n  // Make sure entry.namespace and module.exports are up to date before we\n  // call getExportByName(entry, name).\n  this.runGetters(names);\n\n  if (runNsSetter && names !== void 0) {\n    names.push('*');\n  }\n\n  // Lazily-initialized object mapping parent module identifiers to parent\n  // module objects whose setters we might need to run.\n  var parents;\n  var parentNames;\n\n  forEachSetter(this, names, function (setter, name, value) {\n    if (parents === void 0) {\n      parents = Object.create(null);\n    }\n\n    if (parentNames === void 0) {\n      parentNames = Object.create(null);\n    }\n\n    var parentId = setter.parent.id;\n\n    // When setters use the shorthand for re-exporting values, we know\n    // which exports in the parent module were modified, and can do less work\n    // when running the parent setters.\n    // parentNames[parentId] is set to false if there are any setters that we do\n    // not know which exports they modify\n    if (setter.exportAs !== void 0 && parentNames[parentId] !== false) {\n      parentNames[parentId] = parentNames[parentId] || [];\n      parentNames[parentId].push(setter.exportAs);\n    } else if (parentNames[parentId] !== false) {\n      parentNames[parentId] = false;\n    }\n\n    parents[parentId] = setter.parent;\n\n    // The param order for setters is `value` then `name` because the `name`\n    // param is only used by namespace exports.\n    setter(value, name);\n  });\n\n  if (! parents) {\n    return;\n  }\n\n  // If any of the setters updated the module.exports of a parent module,\n  // or updated local variables that are exported by that parent module,\n  // then we must re-run any setters registered by that parent module.\n  var parentIDs = Object.keys(parents);\n  var parentIDCount = parentIDs.length;\n\n  for (var i = 0; i < parentIDCount; ++i) {\n    // What happens if parents[parentIDs[id]] === module, or if\n    // longer cycles exist in the parent chain? Thanks to our snapshot\n    // bookkeeping above, the runSetters broadcast will only proceed\n    // as far as there are any actual changes to report.\n    var parent = parents[parentIDs[i]];\n    var parentEntry = entryMap[parent.id];\n    if (parentEntry) {\n      parentEntry.runSetters(\n        parentNames[parentIDs[i]] || void 0,\n        !!parentNames[parentIDs[i]]\n      );\n    }\n  }\n};\n\nfunction createSnapshot(entry, name, newValue) {\n  var newSnapshot = Object.create(null);\n  var newKeys = [];\n\n  if (name === \"*\") {\n    safeKeys(newValue).forEach(function (keyOfValue) {\n      // Evaluating value[key] is risky because the property might be\n      // defined by a getter function that logs a deprecation warning (or\n      // worse) when evaluated. For example, Node uses this trick to display\n      // a deprecation warning whenever crypto.createCredentials is\n      // accessed. Fortunately, when value[key] is defined by a getter\n      // function, it's enough to check whether the getter function itself\n      // has changed, since we are careful elsewhere to preserve getters\n      // rather than prematurely evaluating them.\n      newKeys.push(keyOfValue);\n      newSnapshot[keyOfValue] = normalizeSnapshotValue(\n        utils.valueOrGetter(newValue, keyOfValue)\n      );\n    });\n  } else {\n    newKeys.push(name);\n    newSnapshot[name] = normalizeSnapshotValue(newValue);\n  }\n\n  var oldSnapshot = entry.snapshots[name];\n  if (\n    oldSnapshot &&\n    newKeys.every(function (key) {\n      return oldSnapshot[key] === newSnapshot[key]\n    }) &&\n    newKeys.length === Object.keys(oldSnapshot).length\n  ) {\n    return oldSnapshot;\n  }\n\n  return newSnapshot;\n}\n\nfunction normalizeSnapshotValue(value) {\n  if (value === void 0) return UNDEFINED;\n  if (value !== value && isNaN(value)) return NAN;\n  return value;\n}\n\n// Obtain an array of keys in entry.setters[name] for which we need to run a\n// setter function. If successful, entry.snapshot[name] will be updated and/or\n// entry.newSetters[name] will be removed, so the returned keys will not be\n// returned again until after the snapshot changes again. If the snapshot hasn't\n// changed and there aren't any entry.newSetters[name] keys, this function\n// returns undefined, to avoid allocating an empty array in the common case.\nfunction consumeKeysGivenSnapshot(entry, name, snapshot) {\n  if (entry.snapshots[name] !== snapshot) {\n    entry.snapshots[name] = snapshot;\n    // Since the keys of entry.newSetters[name] are a subset of those of\n    // entry.setters[name], we can consume entry.newSetters[name] here too.\n    delete entry.newSetters[name];\n    return Object.keys(entry.setters[name]);\n  }\n\n  // If new setters have been added to entry.setters (and thus also to\n  // entry.newSetters) since we last recorded entry.snapshots[name], we need to\n  // run those setters (for the first time) in order to consider them up-to-date\n  // with respect to entry.snapshots[name].\n  var news = entry.newSetters[name];\n  var newKeys = news && Object.keys(news);\n  if (newKeys && newKeys.length) {\n    // Consume the new keys so we don't consider them again.\n    delete entry.newSetters[name];\n    return newKeys;\n  }\n}\n\n// Invoke the given callback once for every (setter, name, value) that needs to\n// be called. Note that forEachSetter does not call any setters itself, only the\n// given callback.\nfunction forEachSetter(entry, names, callback) {\n  if (names === void 0) {\n    names = Object.keys(entry.setters);\n  }\n\n  names.forEach(function (name) {\n    // Ignore setters asking for module.exports.__esModule.\n    if (name === \"__esModule\") return;\n\n    var settersByKey = entry.setters[name];\n    if (!settersByKey) return;\n\n    var getter = entry.getters[name];\n    var alreadyCalledConstantGetter =\n      typeof getter === \"function\" &&\n      // Sometimes a getter function will throw because it's called\n      // before the variable it's supposed to return has been\n      // initialized, so we need to know that the getter function has\n      // run to completion at least once.\n      getter.runCount > 0 &&\n      getter.constant;\n\n    var value = getExportByName(entry, name);\n\n    // Although we may have multiple setter functions with different keys in\n    // settersByKey, we can compute a snapshot of value and check it against\n    // entry.snapshots[name] before iterating over the individual setter\n    // functions\n    var snapshot = createSnapshot(entry, name, value);\n\n    var keys = consumeKeysGivenSnapshot(entry, name, snapshot);\n    if (keys === void 0) return;\n\n    keys.forEach(function (key) {\n      var setter = settersByKey[key];\n      if (!setter) {\n        return;\n      }\n\n      // Invoke the setter function with the updated value.\n      callback(setter, name, value);\n\n      if (alreadyCalledConstantGetter) {\n        // If we happen to know this getter function has run successfully\n        // (getter.runCount > 0), and will never return a different value\n        // (getter.constant), then we can forget the corresponding setter,\n        // because we've already reported that constant value. Note that we\n        // can't forget the getter, because we need to remember the original\n        // value in case anyone tampers with entry.module.exports[name].\n        delete settersByKey[key];\n      }\n    });\n  });\n}\n\nfunction getExportByName(entry, name) {\n  if (name === \"*\") {\n    return entry.namespace;\n  }\n\n  if (hasOwn.call(entry.namespace, name)) {\n    return entry.namespace[name];\n  }\n\n  if (entry.module === null) return;\n  var exports = entry.module.exports;\n\n  if (name === \"default\" &&\n      ! (utils.getESModule(exports) &&\n         \"default\" in exports)) {\n    return exports;\n  }\n\n  if (exports == null) {\n    return;\n  }\n\n  return exports[name];\n}\n\nfunction makeUniqueKey() {\n  return Math.random()\n    .toString(36)\n    // Add an incrementing salt to help track key ordering and also\n    // absolutely guarantee we never return the same key twice.\n    .replace(\"0.\", ++keySalt + \"$\");\n}\n\nfunction runGetter(entry, name) {\n  var getter = entry.getters[name];\n  if (!getter) return GETTER_ERROR;\n  try {\n    var result = getter();\n    ++getter.runCount;\n    return result;\n  } catch (e) {}\n  return GETTER_ERROR;\n}\n\nmodule.exports = Entry;\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nvar exports = require(\"/node_modules/meteor/modules/client.js\");\n\n/* Exports */\nPackage._define(\"modules\", exports, {\n  meteorInstall: meteorInstall\n});\n\n})();\n","servePath":"/packages/modules.js"}]